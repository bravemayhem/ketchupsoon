import SwiftUI

enum PollMode {
    case timeSlots
    case availability
}

struct TimeRange: Identifiable {
    let id = UUID()
    let startSlot: TimeSlot
    let endSlot: TimeSlot
    var isSelected: Bool = false
    
    var formattedTimeRange: String {
        let formatter = DateFormatter()
        formatter.timeStyle = .short
        
        let calendar = Calendar.current
        var startComponents = DateComponents()
        startComponents.year = calendar.component(.year, from: startSlot.date)
        startComponents.month = calendar.component(.month, from: startSlot.date)
        startComponents.day = calendar.component(.day, from: startSlot.date)
        startComponents.hour = startSlot.hour
        startComponents.minute = startSlot.minute
        
        var endComponents = startComponents
        endComponents.hour = endSlot.hour
        endComponents.minute = endSlot.minute
        
        guard let startDate = calendar.date(from: startComponents),
              let endDate = calendar.date(from: endComponents) else {
            return ""
        }
        
        return "\(formatter.string(from: startDate)) - \(formatter.string(from: endDate))"
    }
    
    var formattedDate: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "EEEE, MMMM d"  // This will show "Tuesday, February 18"
        return formatter.string(from: startSlot.date)
    }
    
    func splitIntoTimeSlots(duration: TimeInterval) -> [TimeRange] {
        let calendar = Calendar.current
        var slots: [TimeRange] = []
        
        // Create start date
        var startComponents = DateComponents()
        startComponents.year = calendar.component(.year, from: startSlot.date)
        startComponents.month = calendar.component(.month, from: startSlot.date)
        startComponents.day = calendar.component(.day, from: startSlot.date)
        startComponents.hour = startSlot.hour
        startComponents.minute = startSlot.minute
        
        // Create end date
        var endComponents = DateComponents()
        endComponents.year = calendar.component(.year, from: endSlot.date)
        endComponents.month = calendar.component(.month, from: endSlot.date)
        endComponents.day = calendar.component(.day, from: endSlot.date)
        endComponents.hour = endSlot.hour
        endComponents.minute = endSlot.minute + 30 // Add 30 minutes to include the end slot
        
        guard let startDate = calendar.date(from: startComponents),
              let rangeEndDate = calendar.date(from: endComponents) else {
            return []
        }
        
        var currentStartDate = startDate
        // For 1-hour slots, we want to slide by 30 minutes each time
        let slideInterval: TimeInterval = 1800 // 30 minutes
        
        while currentStartDate < rangeEndDate {
            guard let slotEndDate = calendar.date(byAdding: .minute, value: Int(duration/60), to: currentStartDate) else {
                break
            }
            
            // Only add the slot if it fits entirely within our range
            if slotEndDate <= rangeEndDate {
                let startSlot = TimeSlot(
                    date: currentStartDate,
                    hour: calendar.component(.hour, from: currentStartDate),
                    minute: calendar.component(.minute, from: currentStartDate)
                )
                
                let endComponents = calendar.dateComponents([.hour, .minute], from: slotEndDate)
                let endSlot = TimeSlot(
                    date: currentStartDate,
                    hour: endComponents.hour ?? 0,
                    minute: endComponents.minute ?? 0
                )
                
                slots.append(TimeRange(startSlot: startSlot, endSlot: endSlot, isSelected: false))
            }
            
            // For 1-hour slots, slide by 30 minutes. For 30-minute slots, slide by the full duration
            let slideAmount = duration == 3600 ? slideInterval : duration
            guard let nextStartDate = calendar.date(byAdding: .minute, value: Int(slideAmount/60), to: currentStartDate) else {
                break
            }
            currentStartDate = nextStartDate
        }
        
        return slots
    }
}

@MainActor
class PollOptionsViewModel: ObservableObject {
    @Published var timeRanges: [TimeRange]
    @Published var showingFindTimeView = false
    @Published var pollMode: PollMode = .availability
    @Published var slotDuration: TimeInterval = 1800 // 30 minutes in seconds
    
    private var originalRanges: [TimeRange] = []
    
    init(selectedTimeSlots: Set<TimeSlot>) {
        self.originalRanges = PollOptionsViewModel.createTimeRanges(from: selectedTimeSlots)
        self.timeRanges = self.originalRanges
    }
    
    private static func createTimeRanges(from timeSlots: Set<TimeSlot>) -> [TimeRange] {
        // Sort time slots by date and time
        let sortedSlots = timeSlots.sorted { slot1, slot2 in
            if slot1.date == slot2.date {
                if slot1.hour == slot2.hour {
                    return slot1.minute < slot2.minute
                }
                return slot1.hour < slot2.hour
            }
            return slot1.date < slot2.date
        }
        
        var ranges: [TimeRange] = []
        var currentRange: (start: TimeSlot, end: TimeSlot)? = nil
        
        for slot in sortedSlots {
            if let current = currentRange {
                // Check if this slot is consecutive with current range
                let calendar = Calendar.current
                var currentEndComponents = DateComponents()
                currentEndComponents.year = calendar.component(.year, from: current.end.date)
                currentEndComponents.month = calendar.component(.month, from: current.end.date)
                currentEndComponents.day = calendar.component(.day, from: current.end.date)
                currentEndComponents.hour = current.end.hour
                currentEndComponents.minute = current.end.minute + 30
                
                var slotComponents = DateComponents()
                slotComponents.year = calendar.component(.year, from: slot.date)
                slotComponents.month = calendar.component(.month, from: slot.date)
                slotComponents.day = calendar.component(.day, from: slot.date)
                slotComponents.hour = slot.hour
                slotComponents.minute = slot.minute
                
                guard let currentEndDate = calendar.date(from: currentEndComponents),
                      let slotDate = calendar.date(from: slotComponents) else {
                    continue
                }
                
                if calendar.isDate(currentEndDate, equalTo: slotDate, toGranularity: .minute) {
                    // Extend current range
                    currentRange?.end = slot
                } else {
                    // End current range and start new one
                    ranges.append(TimeRange(startSlot: current.start, endSlot: current.end))
                    currentRange = (start: slot, end: slot)
                }
            } else {
                // Start new range
                currentRange = (start: slot, end: slot)
            }
        }
        
        // Add last range if exists
        if let lastRange = currentRange {
            ranges.append(TimeRange(startSlot: lastRange.start, endSlot: lastRange.end))
        }
        
        return ranges.sorted { $0.startSlot.date < $1.startSlot.date }
    }
    
    func updateTimeRanges() {
        switch pollMode {
        case .availability:
            timeRanges = originalRanges
        case .timeSlots:
            timeRanges = originalRanges.flatMap { $0.splitIntoTimeSlots(duration: slotDuration) }
        }
    }
    
    func toggleOption(_ range: TimeRange) {
        if let index = timeRanges.firstIndex(where: { $0.id == range.id }) {
            timeRanges[index].isSelected.toggle()
        }
    }
}

struct PollOptionsView: View {
    @StateObject private var viewModel: PollOptionsViewModel
    @Environment(\.dismiss) private var dismiss
    
    init(selectedTimeSlots: Set<TimeSlot>) {
        _viewModel = StateObject(wrappedValue: PollOptionsViewModel(selectedTimeSlots: selectedTimeSlots))
    }
    
    var body: some View {
        NavigationStack {
            List {
                Section {
                    Picker("Poll Mode", selection: $viewModel.pollMode) {
                        Text("Availability").tag(PollMode.availability)
                        Text("Time Slots").tag(PollMode.timeSlots)
                    }
                    .pickerStyle(.segmented)
                    .onChange(of: viewModel.pollMode) { _, _ in
                        viewModel.updateTimeRanges()
                    }
                    
                    if viewModel.pollMode == .timeSlots {
                        Picker("Slot Duration", selection: $viewModel.slotDuration) {
                            Text("30 min").tag(TimeInterval(1800))
                            Text("1 hour").tag(TimeInterval(3600))
                        }
                        .pickerStyle(.segmented)
                        .onChange(of: viewModel.slotDuration) { _, _ in
                            viewModel.updateTimeRanges()
                        }
                    }
                }
                
                Section {
                    ForEach(viewModel.timeRanges) { range in
                        TimeRangeRow(range: range) {
                            viewModel.toggleOption(range)
                        }
                    }
                } header: {
                    Text("Select your preferred time slots")
                        .textCase(nil)
                        .font(.headline)
                        .foregroundColor(.primary)
                        .padding(.bottom, 8)
                }
                
                Section {
                    Button(action: {
                        // TODO: Implement share functionality
                    }) {
                        HStack {
                            Text("Share Poll")
                                .foregroundColor(AppColors.accent)
                            Spacer()
                            Image(systemName: "square.and.arrow.up")
                                .foregroundColor(AppColors.accent)
                        }
                    }
                    .disabled(viewModel.timeRanges.isEmpty)
                }
            }
            .navigationTitle("Poll Options")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Edit") {
                        viewModel.showingFindTimeView = true
                    }
                    .foregroundColor(AppColors.accent)
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                    .foregroundColor(AppColors.accent)
                }
            }
            .sheet(isPresented: $viewModel.showingFindTimeView) {
                FindTimeView()
            }
        }
    }
}

struct TimeRangeRow: View {
    let range: TimeRange
    let onTap: () -> Void
    
    var body: some View {
        Button(action: onTap) {
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text(range.formattedDate)
                        .font(.headline)
                    Text(range.formattedTimeRange)
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
                
                Spacer()
                
                if range.isSelected {
                    Image(systemName: "checkmark.circle.fill")
                        .foregroundColor(AppColors.accent)
                } else {
                    Image(systemName: "circle")
                        .foregroundColor(.gray)
                }
            }
        }
        .foregroundColor(.primary)
    }
}

#Preview {
    let timeSlots: Set<TimeSlot> = [
        TimeSlot(date: Date(), hour: 10, minute: 0),
        TimeSlot(date: Date(), hour: 10, minute: 30),
        TimeSlot(date: Date().addingTimeInterval(86400), hour: 14, minute: 30),
        TimeSlot(date: Date().addingTimeInterval(86400), hour: 15, minute: 0)
    ]
    return PollOptionsView(selectedTimeSlots: timeSlots)
} 